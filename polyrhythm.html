<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Polyrhythm Generator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        /* Custom styles (minimal, mostly relying on Tailwind) */
        body {
            font-family: 'Inter', sans-serif; /* Use Inter font */
        }
        /* Style for the 'beat' flash effect */
        .beat-dot.playing {
            /* Tailwind classes could be used here too via JS,
               but direct style manipulation or CSS class toggling is often simpler for transitions */
            transition: r 0.05s ease-out, opacity 0.05s ease-out;
        }
        /* Ensure SVG takes available space and is centered */
        #visualization {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 90%; /* Responsive width */
            max-width: 500px; /* Max size */
            aspect-ratio: 1 / 1; /* Maintain square aspect ratio */
            margin: 1rem auto; /* Centering */
        }
        #viz-svg {
            width: 100%;
            height: 100%;
            border-radius: 50%; /* Make the SVG background visually circular */
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1); /* Tailwind shadow equivalent */
        }
        /* Dashed lines for paths */
        .path-circle {
            fill: none;
            stroke-width: 2px;
            stroke-dasharray: 5 3;
        }
        .beat-dot {
            stroke: #333;
            stroke-width: 1px;
        }
        /* Custom focus rings for accessibility */
        input[type="range"]:focus {
            outline: 2px solid transparent;
            outline-offset: 2px;
            box-shadow: 0 0 0 3px rgba(66, 153, 225, 0.5); /* Example focus ring */
        }
        button:focus {
           outline: 2px solid transparent;
           outline-offset: 2px;
           box-shadow: 0 0 0 3px rgba(66, 153, 225, 0.5); /* Example focus ring */
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
</head>
<body class="bg-gray-100 text-gray-800 flex flex-col items-center min-h-screen p-4">

    <h1 class="text-3xl font-bold text-gray-900 mb-6">Polyrhythm Generator</h1>

    <div id="controls" class="mb-6 p-6 bg-white rounded-lg shadow-md w-full max-w-2xl flex flex-col items-center space-y-4">
        <button id="startStopButton" class="px-6 py-2 bg-green-500 hover:bg-green-600 text-white font-bold rounded-md transition duration-150 ease-in-out focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-400">
            Start
        </button>

        <div class="w-full flex flex-col sm:flex-row items-center justify-between space-y-2 sm:space-y-0 sm:space-x-4 p-3 border border-gray-200 rounded-md">
            <label for="tempo" class="font-medium text-sm whitespace-nowrap">Tempo (BPM): <span id="tempoValue" class="font-bold text-indigo-600">120</span></label>
            <input type="range" id="tempo" min="30" max="240" value="120" step="1" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer dark:bg-gray-700">
        </div>

        <div class="w-full flex flex-col sm:flex-row items-center justify-between space-y-2 sm:space-y-0 sm:space-x-4 p-3 border-l-4 border-blue-500 bg-blue-50 rounded-md">
            <label for="rhythm1Beats" class="font-medium text-sm whitespace-nowrap">Rhythm 1 Beats: <span id="rhythm1Value" class="font-bold text-blue-700">3</span></label>
            <input type="range" id="rhythm1Beats" min="1" max="16" value="3" step="1" class="w-full h-2 bg-blue-200 rounded-lg appearance-none cursor-pointer dark:bg-blue-700">
            <label for="freq1" class="font-medium text-sm whitespace-nowrap ml-0 sm:ml-4">Freq 1 (Hz): <span id="freq1Value" class="font-bold text-blue-700">440</span></label>
            <input type="range" id="freq1" min="100" max="1000" value="440" step="10" class="w-full h-2 bg-blue-200 rounded-lg appearance-none cursor-pointer dark:bg-blue-700">
        </div>

        <div class="w-full flex flex-col sm:flex-row items-center justify-between space-y-2 sm:space-y-0 sm:space-x-4 p-3 border-l-4 border-red-500 bg-red-50 rounded-md">
            <label for="rhythm2Beats" class="font-medium text-sm whitespace-nowrap">Rhythm 2 Beats: <span id="rhythm2Value" class="font-bold text-red-700">2</span></label>
            <input type="range" id="rhythm2Beats" min="1" max="16" value="2" step="1" class="w-full h-2 bg-red-200 rounded-lg appearance-none cursor-pointer dark:bg-red-700">
            <label for="freq2" class="font-medium text-sm whitespace-nowrap ml-0 sm:ml-4">Freq 2 (Hz): <span id="freq2Value" class="font-bold text-red-700">660</span></label>
            <input type="range" id="freq2" min="100" max="1000" value="660" step="10" class="w-full h-2 bg-red-200 rounded-lg appearance-none cursor-pointer dark:bg-red-700">
        </div>

         <div class="w-full flex flex-col sm:flex-row items-center justify-between space-y-2 sm:space-y-0 sm:space-x-4 p-3 border border-gray-200 rounded-md">
            <label for="volume" class="font-medium text-sm whitespace-nowrap">Volume: <span id="volumeValue" class="font-bold text-indigo-600">0.5</span></label>
            <input type="range" id="volume" min="0" max="1" value="0.5" step="0.05" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer dark:bg-gray-700">
        </div>
    </div>

    <div id="visualization">
        <svg id="viz-svg" class="bg-white rounded-full"></svg>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- Audio Setup ---
            let audioContext; // AudioContext instance
            let masterGain;   // Master GainNode for overall volume
            let isPlaying = false; // Flag to track playback state
            let schedulerIntervalId = null; // ID for the setInterval timer
            let nextNoteTimeRhythm1 = 0.0; // Time for the next note of rhythm 1
            let nextNoteTimeRhythm2 = 0.0; // Time for the next note of rhythm 2
            const scheduleAheadTime = 0.1; // (seconds) How far ahead to schedule audio events
            const schedulerFrequency = 25; // (ms) How often the scheduler function runs

            // --- Parameters ---
            // Initial values are set from HTML, these variables hold the current state
            let tempo = 120;
            let rhythm1Beats = 3;
            let rhythm2Beats = 2;
            let freq1 = 440;
            let freq2 = 660;
            let volume = 0.5;
            let cycleDuration = 60.0 / tempo; // Duration (seconds) of one full polyrhythm cycle
            let interval1 = cycleDuration / rhythm1Beats; // Time between beats for rhythm 1
            let interval2 = cycleDuration / rhythm2Beats; // Time between beats for rhythm 2
            const noteDuration = 0.05; // (seconds) Duration of the synthesized sound

            // --- D3 Visualization Setup ---
            const svgElement = document.getElementById('viz-svg');
            const svg = d3.select(svgElement);
            let width = svgElement.clientWidth; // Get width from the element
            let height = svgElement.clientHeight; // Get height from the element
            let radius = Math.min(width, height) / 2 * 0.85; // Main radius for visualization paths
            let center = { x: width / 2, y: height / 2 };

            // Create a group for easier centering and rotation
            const vizGroup = svg.append("g")
                .attr("transform", `translate(${center.x}, ${center.y})`);

            // Define radii for the two rhythm paths
            const radius1 = radius * 0.9;
            const radius2 = radius * 0.7;

            // Draw static path circles (visual guides)
            vizGroup.append("circle")
                .attr("class", "path-circle")
                .attr("id", "path1")
                .attr("r", radius1)
                .style("stroke", "rgb(59 130 246)"); // Tailwind blue-500

            vizGroup.append("circle")
                .attr("class", "path-circle")
                .attr("id", "path2")
                .attr("r", radius2)
                .style("stroke", "rgb(239 68 68)"); // Tailwind red-500

            // Add moving dots for beats
            const beatDot1 = vizGroup.append("circle")
                .attr("class", "beat-dot")
                .attr("id", "dot1")
                .attr("r", 8) // Radius of the dot
                .attr("fill", "rgb(59 130 246 / 0.8)") // Tailwind blue-500 with some transparency
                .attr("cx", radius1) // Start at 3 o'clock position (angle 0)
                .attr("cy", 0);

            const beatDot2 = vizGroup.append("circle")
                .attr("class", "beat-dot")
                .attr("id", "dot2")
                .attr("r", 8) // Radius of the dot
                .attr("fill", "rgb(239 68 68 / 0.8)") // Tailwind red-500 with some transparency
                .attr("cx", radius2) // Start at 3 o'clock position
                .attr("cy", 0);


            // --- DOM Element References ---
            const startStopButton = document.getElementById('startStopButton');
            const tempoSlider = document.getElementById('tempo');
            const tempoValueSpan = document.getElementById('tempoValue');
            const rhythm1Slider = document.getElementById('rhythm1Beats');
            const rhythm1ValueSpan = document.getElementById('rhythm1Value');
            const rhythm2Slider = document.getElementById('rhythm2Beats');
            const rhythm2ValueSpan = document.getElementById('rhythm2Value');
            const freq1Slider = document.getElementById('freq1');
            const freq1ValueSpan = document.getElementById('freq1Value');
            const freq2Slider = document.getElementById('freq2');
            const freq2ValueSpan = document.getElementById('freq2Value');
            const volumeSlider = document.getElementById('volume');
            const volumeValueSpan = document.getElementById('volumeValue');

            // --- Initial Parameter Display ---
            // Function to update display and parameters (called initially and on slider input)
            function updateParameters() {
                tempo = parseFloat(tempoSlider.value);
                rhythm1Beats = parseInt(rhythm1Slider.value);
                rhythm2Beats = parseInt(rhythm2Slider.value);
                freq1 = parseFloat(freq1Slider.value);
                freq2 = parseFloat(freq2Slider.value);
                volume = parseFloat(volumeSlider.value);

                // Update display spans
                tempoValueSpan.textContent = tempo;
                rhythm1ValueSpan.textContent = rhythm1Beats;
                rhythm2ValueSpan.textContent = rhythm2Beats;
                freq1ValueSpan.textContent = freq1;
                freq2ValueSpan.textContent = freq2;
                volumeValueSpan.textContent = volume.toFixed(2);

                // Recalculate timing based on new parameters
                cycleDuration = 60.0 / tempo;
                interval1 = cycleDuration / rhythm1Beats;
                interval2 = cycleDuration / rhythm2Beats;

                // Update master gain volume smoothly if audio context exists
                if (masterGain && audioContext) {
                    masterGain.gain.linearRampToValueAtTime(volume, audioContext.currentTime + 0.05);
                }

                // If playing, reset scheduler timing to apply changes immediately
                // This ensures the *next* scheduled notes use the new intervals.
                if (isPlaying && audioContext) {
                     const currentTime = audioContext.currentTime;
                     // Adjust next note times based on the *phase* within the new interval structure
                     // A simpler approach for now: reset to start immediately on parameter change
                     nextNoteTimeRhythm1 = currentTime;
                     nextNoteTimeRhythm2 = currentTime;
                     startTime = currentTime; // Reset animation start time as well
                     console.log("Parameters updated, resetting scheduler timing.");
                }
            }

            // --- Audio Functions ---
            // Initialize the AudioContext (must be done on user gesture)
            function initAudioContext() {
                if (!audioContext) {
                    try {
                        audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        masterGain = audioContext.createGain();
                        masterGain.gain.setValueAtTime(volume, audioContext.currentTime);
                        masterGain.connect(audioContext.destination);
                        console.log("AudioContext initialized.");
                    } catch (e) {
                        console.error("Web Audio API is not supported in this browser", e);
                        alert("Sorry, the Web Audio API is needed for this generator and is not supported by your browser.");
                        return false; // Indicate failure
                    }
                }
                 // Resume context if it was suspended (e.g., by browser policies after inactivity)
                if (audioContext.state === 'suspended') {
                    audioContext.resume().then(() => {
                         console.log("AudioContext resumed.");
                    });
                }
                return true; // Indicate success
            }

            // Play a single note at a specific time and frequency
            function playNote(time, frequency, gainNode) {
                if (!audioContext) return; // Safety check

                const oscillator = audioContext.createOscillator();
                oscillator.type = 'sine'; // Simple tone
                oscillator.frequency.setValueAtTime(frequency, time);

                // Create an envelope for a short 'click' or 'beep' sound
                const envelope = audioContext.createGain();
                // Start at the master gain level effectively
                envelope.gain.setValueAtTime(1.0, time);
                // Decay quickly to near silence
                envelope.gain.exponentialRampToValueAtTime(0.001, time + noteDuration);

                // Connect oscillator -> envelope -> master gain -> destination
                oscillator.connect(envelope);
                envelope.connect(gainNode);

                oscillator.start(time);
                // Schedule stop slightly after the envelope decay finishes
                oscillator.stop(time + noteDuration + 0.05);
            }

            // --- Scheduler ---
            // This function runs periodically to schedule upcoming notes
            function scheduleNotes() {
                if (!isPlaying || !audioContext) return; // Only run if playing and audio is ready

                const currentTime = audioContext.currentTime;

                // Schedule notes for Rhythm 1 if they fall within the lookahead window
                while (nextNoteTimeRhythm1 < currentTime + scheduleAheadTime) {
                    playNote(nextNoteTimeRhythm1, freq1, masterGain);
                    // Trigger visual flash slightly delayed to sync better visually if needed,
                    // or trigger immediately based on schedule time. Immediate is simpler.
                    triggerVisualFlash('dot1', 50); // 50ms flash duration
                    // Advance the next note time for rhythm 1
                    nextNoteTimeRhythm1 += interval1;
                }

                // Schedule notes for Rhythm 2
                while (nextNoteTimeRhythm2 < currentTime + scheduleAheadTime) {
                    playNote(nextNoteTimeRhythm2, freq2, masterGain);
                    triggerVisualFlash('dot2', 50);
                    // Advance the next note time for rhythm 2
                    nextNoteTimeRhythm2 += interval2;
                }
            }

            // --- Visualisation Update ---
            let animationFrameId = null; // ID for the requestAnimationFrame loop
            let startTime = 0; // Reference time (from audioContext) for animation cycle start

            // Function to update the visual elements (dots)
            function animateVisuals() {
                 if (!isPlaying || !audioContext) {
                    // Ensure dots are reset to start position if stopped
                    beatDot1.attr("transform", `rotate(0)`);
                    beatDot2.attr("transform", `rotate(0)`);
                    animationFrameId = null; // Stop the animation loop
                    return;
                }

                const elapsed = audioContext.currentTime - startTime;

                // Calculate the current phase (0 to 1) within one full cycle duration
                const cyclePhase = (elapsed % cycleDuration) / cycleDuration;

                // Calculate the angle for each dot based on its beat count and the cycle phase
                // Angle = phase * 360 degrees * number of beats in the cycle
                const angle1 = cyclePhase * 360 * rhythm1Beats;
                const angle2 = cyclePhase * 360 * rhythm2Beats;

                // Apply rotation transform to the dots.
                // D3 rotates around the group's origin (which we set to the center).
                beatDot1.attr("transform", `rotate(${angle1})`);
                beatDot2.attr("transform", `rotate(${angle2})`);

                // Keep the animation loop going
                animationFrameId = requestAnimationFrame(animateVisuals);
            }

             // Function to visually flash a dot when its note plays
            function triggerVisualFlash(dotId, durationMs = 100) {
                const dot = d3.select(`#${dotId}`);
                if (dot) {
                    dot.classed("playing", true) // Add class for potential CSS styling
                       .transition()
                       .duration(durationMs * 0.4) // Fast flash up
                       .attr("r", 12) // Increase size
                       .style("opacity", 1.0) // Ensure full opacity
                       .transition()
                       .duration(durationMs * 0.6) // Slower fade back
                       .attr("r", 8) // Back to normal size
                       .style("opacity", null) // Back to original opacity (or set explicitly if needed)
                       .on("end", () => dot.classed("playing", false)); // Remove class after transition
                }
            }

            // --- Control Logic ---
            // Function to start playback
            function start() {
                if (isPlaying) return; // Do nothing if already playing

                // Initialize AudioContext on first start attempt
                if (!initAudioContext()) {
                    return; // Stop if audio context failed
                }

                isPlaying = true;
                startStopButton.textContent = 'Stop';
                // Update button style using Tailwind classes
                startStopButton.classList.remove('bg-green-500', 'hover:bg-green-600', 'focus:ring-green-400');
                startStopButton.classList.add('bg-red-500', 'hover:bg-red-600', 'focus:ring-red-400');

                // Reset next note times based on current audio time to start immediately
                const currentTime = audioContext.currentTime;
                nextNoteTimeRhythm1 = currentTime;
                nextNoteTimeRhythm2 = currentTime;
                startTime = currentTime; // Reset animation start time

                // Start the scheduler interval
                if (schedulerIntervalId) clearInterval(schedulerIntervalId); // Clear previous interval if any
                scheduleNotes(); // Schedule the first batch immediately
                schedulerIntervalId = setInterval(scheduleNotes, schedulerFrequency);

                // Start the animation loop
                if (animationFrameId) cancelAnimationFrame(animationFrameId); // Clear previous frame if any
                animationFrameId = requestAnimationFrame(animateVisuals);

                console.log("Playback started.");
            }

            // Function to stop playback
            function stop() {
                if (!isPlaying) return; // Do nothing if already stopped

                isPlaying = false;
                startStopButton.textContent = 'Start';
                 // Update button style using Tailwind classes
                startStopButton.classList.remove('bg-red-500', 'hover:bg-red-600', 'focus:ring-red-400');
                startStopButton.classList.add('bg-green-500', 'hover:bg-green-600', 'focus:ring-green-400');

                // Stop the scheduler
                if (schedulerIntervalId) {
                    clearInterval(schedulerIntervalId);
                    schedulerIntervalId = null;
                }

                 // Stop the animation loop
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null; // Signal loop to stop in the next check
                }

                // Optional: Suspend audio context after a short delay to save resources
                // if (audioContext) {
                //     setTimeout(() => {
                //         if (!isPlaying) audioContext.suspend().then(() => console.log("AudioContext suspended."));
                //     }, 1000); // Suspend after 1 second of inactivity
                // }

                console.log("Playback stopped.");
            }

            // --- Resize Handling ---
            // Function to recalculate sizes on window resize
            function handleResize() {
                width = svgElement.clientWidth;
                height = svgElement.clientHeight;
                radius = Math.min(width, height) / 2 * 0.85;
                center = { x: width / 2, y: height / 2 };

                // Update the main group transform
                vizGroup.attr("transform", `translate(${center.x}, ${center.y})`);

                // Update static circle radii and dot positions (cx)
                const newRadius1 = radius * 0.9;
                const newRadius2 = radius * 0.7;
                d3.select("#path1").attr("r", newRadius1);
                d3.select("#path2").attr("r", newRadius2);
                beatDot1.attr("cx", newRadius1);
                beatDot2.attr("cx", newRadius2);

                // Re-apply current rotation if playing
                if (isPlaying && audioContext) {
                     const elapsed = audioContext.currentTime - startTime;
                     const cyclePhase = (elapsed % cycleDuration) / cycleDuration;
                     const angle1 = cyclePhase * 360 * rhythm1Beats;
                     const angle2 = cyclePhase * 360 * rhythm2Beats;
                     beatDot1.attr("transform", `rotate(${angle1})`);
                     beatDot2.attr("transform", `rotate(${angle2})`);
                } else {
                    // Ensure dots are reset if not playing
                    beatDot1.attr("transform", `rotate(0)`);
                    beatDot2.attr("transform", `rotate(0)`);
                }
            }

            // --- Event Listeners ---
            // Start/Stop button
            startStopButton.addEventListener('click', () => {
                if (isPlaying) {
                    stop();
                } else {
                    start();
                }
            });

            // Sliders - update parameters on input
            tempoSlider.addEventListener('input', updateParameters);
            rhythm1Slider.addEventListener('input', updateParameters);
            rhythm2Slider.addEventListener('input', updateParameters);
            freq1Slider.addEventListener('input', updateParameters);
            freq2Slider.addEventListener('input', updateParameters);
            volumeSlider.addEventListener('input', updateParameters);

            // Window resize listener
            let resizeTimeout;
            window.addEventListener('resize', () => {
                // Debounce resize event for performance
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(handleResize, 100); // Adjust delay as needed
            });

            // --- Initial Setup ---
            updateParameters(); // Calculate initial intervals and display values
            handleResize(); // Initial sizing of the visualization

        }); // End DOMContentLoaded
    </script>
</body>
</html>
